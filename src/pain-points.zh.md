
## 痛点

可以说 Rust 是一门比大多数"主流"语言更难学的语言. 有特殊的人不觉得这么难,但要注意'特殊'的严格意义 - 他们是 _例外_. 一开始许多人挣扎,后成功. 最初的困难是不能预测后来的!

我们都来自某个地方,在编程语言的情况下,这意味着以前主流语言的遗留,如Python之类的"动态"语言 或 C ++之类的"静态"语言之一. 无论哪种方式, Rust 都有很大的不同,需要转变思路. 有经验的聪明人 加入进来,对他们的聪明不立即获得回报感到失望;自我 值 较低的人 认为自己不够"聪明". 

对于那些具有动态语言经验的人 (我将包括Java) ,所有内容都是 `引用&`,并且所有引用默认都是可变的. 和垃圾收集 _会_ 使编写内存安全的程序更容易. 以内存使用和可预测性为代价,JVM进展非常迅速. 通常这种成本被认为是值得的 - 旧的新想法认为程序员的生产力 比 计算机的性能更重要. 

但是世界上大多数电脑 - 处理汽车阀门控制 等真正重要的事情 - 并不具备便宜笔记本电脑所拥有的大量资源,而且他们需要 _即时的_ 响应. 同样,基础软件基础架构需要 正确,稳健和快速 (旧的工程三位一体) . 这大部分都是在本质上是不安全的 C和C ++ 中完成的,这个不安全的东西的 _总成本_ 是在这里看的东西. 也许你更快地组合项目,但是 _之后_ 真正的开发才开始. 

系统语言无法承担垃圾回收,因为它们是所有东西都依赖的基础. 只要你认为合适,他们让你可以自由地浪费资源. 

如果没有垃圾回收,则内存必须以其他方式进行管理. _手动内存管理_ - 我抓住内存,使用它,并明确地将其退回 - 很难找到正确的内容. 您可以在几周内学会足够的C语言以提高工作效率和危险性 - 但要成为一名安全的C语言程序员需要花费数年时间,并检查每种可能的错误情况. 

 Rust 像现代C ++一样管理内存 - 随着对象被破坏,内存被回收. 你可以在堆上分配内存`Box`,但只要该函数在函数结束,'超出范围'时,内存就会被回收. 所以有像`new{新建}`这样的事情但没有`删除{delete}`. 你可以创建一个`File`,和在最后文件控制 (一个宝贵的资源) 被闭包. 在 Rust 中,这被称为 _扔掉{dropping}_. 

你需要共享资源 - 复制一切都是非常低效的 - 这就是事情变得有趣的地方. C ++也有引用,尽管 Rust 引用更像C指针 - 你需要使用`*r`才能用  值 {value} ,你需要说`&`一个值作为引用传递. 

 Rust 的 _借用检查器_ 确保在原始值被销毁后引用不可能存在. 

## 类型推断

"静态"和"动态"之间的区别不是一切. 与大多数事情一样,还有更多维度在发挥. C 是静态类型的 (每个变量在编译时都有一个类型) ,但是类型很弱 (例如,`void*`可以指向 _任何{anything}_) ;Python是动态类型的 (类型在值中,而不是变量) ,但却是强类型的. Java是静态/非常强类型的 (反射「reflection」 就像 方便/危险的逃逸阀) , Rust 是静态/强类型的,没有运行时反射. 

Java因需要在麻木的细节中 _键入_ 所有的类型而出名, Rust 喜欢 _推断_ 类型. 这通常是一个好主意,但这确实意味着你有时需要计算出实际类型. 你会看见`let n = 100`并想知道 - 这是什么样的整数? 默认情况下,它会是`i32`- 一个四字节有符号整数. 现在大家都同意 C 的未指定整数类型 (比如`int`和`long`) 是一个坏主意; 最好是明确的. 你可以随时拼出类型,如`let n: u32 = 100`或者让文字强制类型,如`let n = 100u32`. 但是类型推断比这更进一步! 如果你声明`let n = 100`然后全部`rustc`知道这一点`n`一定是 _一些_ 整数类型. 如果你然后通过`n`到一个期望一个`u64`函数, 那么这一定是这种类型的`n`!

之后,你尝试给`n`到期望`u32`函数. ` rustc`不会让你这样做,因为`n`已被束缚到`u64`和它 _将不会_ 采取简单的方法为您转换该整数. 这是强有力的类型行动 - 没有任何一点转换和促销活动让你的生活更流畅,直到整数溢出突然咬住你的屁股. 你必须明确地通过`n`如`n as u32`- 一个 Rust 类型. 幸好,` rustc`善于以"可行"的方式打破坏消息 - 也就是说,您可以按照编译器的意见来解决问题. 

所以, Rust 代码可以非常明确的类型: 

``` Rust 
let mut v = Vec::new();
// v is deduced to have type Vec<i32>
v.push(10);
v.push(20);
v.push("hello") <--- just can't do this, man!
```

不能将字符串放入整数 Vec 是一个功能,而不是一个错误. 动态类型的灵活性也是一个诅咒. 

 (如果你将需要 _把_ 整数和字符串放入同一个 Vec ,那么 Rust `枚举`类型是安全地使用它的方法. ) 

有时你需要至少给一个类型 _暗示_. `collect`是一个梦幻般的迭代器方法,但它需要一个提示. 说我有一个迭代器返回`char`. 然后`collect`可以摆动两种方式: 

``` Rust 
// a vector of char ['h','e','l','l','o']
let v: Vec<_> = "hello".chars().collect();
// a string "doy"
let m: String = "dolly".chars().filter(|&c| c != 'l').collect();
```

当对某个变量的类型感到不确定时,总会有这种技巧,`rustc`这种力量在错误消息中显示实际类型名称: 

``` Rust 
let x: () = var;
```

` rustc`可能会选择特定类型. 这里我们想把不同的引用放入一个 Vec 但需要使用`&Debug`明确声明类型. 

``` Rust 
use std::fmt::Debug;

let answer = 42;
let message = "hello";
let float = 2.7212;

let display: Vec<&Debug> = vec![&message, &answer, &float];

for d in display {
    println!("got {:?}", d);
}
```

## 可变引用

规则是: 一次只有一个可变引用. 原因在于追踪 _到处都是_ 可变性很难. 在小笨蛋程序中不明显,但在大型代码库中可能会变得糟糕. 

进一步的限制是,当有可变引用出现时,你不能拥有不可变引用. 否则,任何有这些引用的人都不能保证他们不会改变. C ++也有不可变的引用 (例如`const string&`) 但是 _不能_ 给你这个保证,是因为有人不能保留一个`string&`引用并在背后修改它. 

如果您习惯于每个引用都是可变的语言,这是一个挑战! 不安全的"放松"语言取决于人们了解他们自己的计划并高高兴兴地决定不做坏事. 但是大型项目是由不止一个人编写的,并且超出了单个人详细理解的能力. 

该 _刺激性_ 事情是,借用检查器并不像它那样聪明. 

``` Rust 
let mut m = HashMap::new();
m.insert("one", 1);
m.insert("two", 2);

if let Some(r) = m.get_mut("one") { // <-- mutable borrow of m
    *r = 10;
} else {
    m.insert("one", 1); // can't borrow mutably again!
}
```

显然这不是 _真的_ 违反规则,除非如果我们得到了`None`,而实际上并没有从 map 上借用任何东西. 

有各种丑陋的解决方法: 

``` Rust 
let mut found = false;
if let Some(r) = m.get_mut("one") {
    *r = 10;
    found = true;
}
if ! found {
    m.insert("one", 1);
}
```

这很糟糕,但它起作用,因为令人烦恼的借用保留在第一个if语句中. 

这里更好的方法是使用`HashMap`[Entry API](https://doc. Rust -lang.org/std/collections/hash_map/enum.Entry.html). 

``` Rust 
use std::collections::hash_map::Entry;

match m.entry("one") {
    Entry::Occupied(e) => {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) => {
        e.insert(1);
    }
};
```

当 _非词汇生命周期_ 今年某个时候到达, 借用检查器获得更少的挫败感. 

借用检查器 _还是_ 了解一些重要的案例,然而. 如果你有一个结构,字段可以独立借用. 所以构造是你的朋友;一个大结构体应该包含更小的结构体,它们有自己的方法. 当你不能修改内容就定义大结构体上的所有可变方法的情况,即使这些方法可能只涉及一个字段. 

对于可变数据,有一些独立处理数据部分的特殊方法. 例如,如果你有一个可变切片,那么`split_at_mut`将它分成两个可变切片. 这是完全安全的,因为 Rust 知道切片不重叠. 

## 引用和生命时间

 Rust 不能允许一个引用超过 值 的情况. 否则,我们会有一个"悬挂引用",它指的是一个死亡值 - 一个段错误是不可避免的. 

` rustc`往往可以对函数的生命周期做出合理的假设: 

``` Rust 
fn pair(s: &str, ch: char) -> (&str, &str) {
    if let Some(idx) = s.find(ch) {
        (&s[0..idx], &s[idx+1..])
    } else {
        (s, "")
    }
}
fn main() {
    let p = pair("hello:dolly", ':');
    println!("{:?}", p);
}
// ("hello", "dolly")
```

这是非常安全的,因为我们处理了未找到分隔符的情况. ` rustc`在这里假定元组中的两个字符串都是从作为参数传递给函数的字符串中借用的. 

明确地说,函数定义如下所示: 

``` Rust 
fn pair<'a>(s: &'a str, ch: char) -> (&'a str, &'a str) {...}
```

符号表示输出字符串存在 _至少与输入字符串一样长_ . 这并不是说生命是一样的,我们可以在任何时候放弃它们,只是因为它们无法离开`s`. 

所以,` rustc`使常见案例更漂亮 _生命豁免_. 

现在,如果收到该函数 _两个_ 字符串,那么您需要明确地进行生命周期注释来告诉 Rust 哪个输出字符串是从哪个输入字符串中借用的. 

当一个结构借用一个引用时,你总是需要一个明确的生命周期: 

``` Rust 
struct Container<'a> {
    s: &'a str
}
```

这再次坚持结构不能超过引用. 对于结构和函数,生命周期都需要在中声明`<>`像一个类型参数. 

闭包是非常方便和强类型的功能 -   Rust 迭代器的很多强类型函数都来自它们. 但是如果你存储它们,你必须指定一个生命周期. 这是因为基本上闭包是一个可以调用的生成结构,并且默认情况下是借用它的环境. 在这里`linear`闭包有不可改变的引用`m`和`c`. 

``` Rust 
let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c;
let sc = |x| m*x.cos()
...
```

`linear`和`sc`都实行`Fn(x: f64)->f64`但他们是 _不是_ 同样的动物 - 他们有不同的类型和大小! 所以要存储它们,你必须做出一个`Box<Fn(x: f64)->f64 + 'a>`. 

非常烦人,如果你习惯了JavaScript 或 Lua 的流畅闭包,但C ++与 Rust 类似,并且需要`std::function`存储不同的闭包,对虚拟呼叫采取一点点惩罚. 

## 字符串

在开始时,通常会对 Rust 字符串感到恼火. 有不同的方式来创建它们,并且它们都感觉冗长: 

``` Rust 
let s1 = "hello".to_string();
let s2 = String::from("dolly");
```

"hello" 不是 _已经是_ 一个字符串? 好吧,在某种程度上. `String`是一个 _拥有的「owned」_ 字符串,分配在堆上; 字符串文字"hello"是类型的`&str` ("字符串切片") ,并可能被烘焙到 可执行 ("静态{static}") 或借用`String`. 系统语言需要这种区别 - 考虑一个微型微控制器,它有 一点RAM 和更多的ROM . 切片字符串 将被存储在ROM ("只读") 中 ,这既便宜又消耗更少的功率. 

但是 (你可能会说) 在C ++中它非常简单: 

```C
std::string s = "hello";
```

其中较短的是,但隐藏了字符串对象的隐式创建. 因此, Rust 喜欢明确分配内存`to_string`. 另一方面,借用一个C ++字符串需要`c_str`,而C字符串很蠢. 

幸运的是, Rust 的情况更好 - _一旦_ 你接受这两个`String`和`&str`是必要的. 方法`String`主要是为了改变字符串,就像`push`添加一个字符 (在引擎盖下它非常像`Vec<u8>`) . 但是所有的方法`&str`也可用. 同样的`Deref`机制,一个`String`可以给`&str`到一个函数 - 这就是为什么你很少看到`&String`在函数定义中. 

有很多方法可以转换`&str`至`String`,对应于各种 trait.  Rust 需要这些 trait来一般地处理类型. 作为一个经验法则,任何实现`Display`也知道`to_string`, 喜欢`42.to_string()`. 

一些运营商可能不会按照直觉行事: 

``` Rust 
    let s1 = "hello".to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == "hello"); // fine
    assert!(s1 == &s2); // WTF?
```

记得,`String`和`&String`是不同的类型,和`==`没有为该组合定义. 这可能会让一个习惯于引用的 C ++人 与数值几乎可以互换. 此外,`&s2`不会 _神奇_ 成为一个`&str`, 那是一个 _deref强制_ 这只在分配给 一个`&str`变量或参数 时才会发生.  (明确的`s2.as_str()`会工作. ) 

但是,这有更真正值得一个WTF: 

``` Rust 
let s3 = s1 + s2;  // <--- no can do
```

你不能连接两个`String`值,但可以连接一个`String`使用`&str`. 此外,您不能连接一个`&str`使用`String`. 所以大多数人不会使用`+`而使用`format!`宏,这很方便,但效率不高. 

有些字符串操作可用,但工作方式不同. 例如,语言通常有一个`split`将字符串分解为字符串数组的方法.  Rust 字符串的这个方法返回一个 _迭代器_ ,你可以 _然后_ collect 成 Vec . 

``` Rust 
let parts: Vec<_> = s.split(',').collect();
```

如果你急于获取 Vec ,这有点笨拙. 但是你可以对零件进行操作 _无_ 分配一个 Vec! 例如,分割中最大的字符串的长度?

``` Rust 
let max = s.split(',').map(|s| s.len()).max().unwrap();
```

 (该`unwrap`是因为空的迭代器没有最大值,我们必须覆盖这种情况. ) 

该`collect`方法返回一个`Vec<&str>`,其中的部分是从原始字符串中借用的 - 我们只需要为引用分配空间. 在C ++中没有像这样的方法,但直到最近才需要单独分配每个子字符串.  (C ++ 17有`std::string_view`其行为像一个 Rust 字符串切片. ) 

## 关于分号的说明

分号是 _不_ 可选的,但通常在与C相同的地方被排除,例如,后`{}`块. 之后他们也不需要`enum`要么`struct` (这是一个C特性. ) 但是,如果该块必须有一个 _值_ ,那么分号将被丢弃: 

``` Rust 
    let msg = if ok {"ok"} else {"error"};
```

请注意,在此之后必须有一个分号在`let `声明之后!

如果在这些字符串之后有分号,那么返回的值就是`()` (像`Nothing`要么`void`) . 定义函数时常见错误: 

``` Rust 
fn sqr(x: f64) -> f64 {
    x * x; // 是 reutrn x * x , 多了 ;
}
```

`rustc`在这种情况下会给你一个明确的错误. 

## 特定于C ++的问题

###  Rust 值语义是不同的

在C ++中,可以定义类型类似于原始并复制它们自己. 另外,可以定义移动构造函数来指定如何将值移出临时上下文. 

在 Rust 里,原始人的行为和预期一样,但是`Copy`trait只能在集合类型 (结构{struct},元组{tuple}或枚举{enum}) 本身只包含可复制类型的情况下定义. 任意类型可能有`Clone`,但你必须使用`clone`方法.  Rust 要求任何分配都是明确的,不要隐藏在复制构造函数或赋值运算符中. 

所以,复制和移动总是被定义为只是 移动位 而不能被覆盖. 

如果`s1`不是`Copy`值类型,像`s2 = s1;`导致移动发生,而这 _消耗_ `s1`!所以,当你真的想要一个副本,使用`clone`. 

借用通常比复制要好,但是你必须遵循借用规则. 幸运的是,借用 _是_ 一个可覆盖的行为. 例如,`String`可以借用成`&str`,并共享所有不可变的方法`&str`.  _字符串切片_ 与类似的C ++"借用{borrowing}"操作相比,这是非常强类型的函数,它将提取一个`const char *`运用`c_str`. `&str`由一个指向一些拥有的字节 (或字符串文字) 指针 和 一个 _尺寸「size」_ 组成. 这导致了一些非常有效的内存模式. 你可以有一个`Vec<&str>`所有的字符串都是从一些底层字符串中借用的 - 只需要分配 Vec 空间: 

例如,按空格拆分: 

``` Rust 
fn split_whitespace(s: &str) -> Vec<&str> {
    s.split_whitespace().collect()
}
```

同样,一个C ++`s.substr(0,2)`调用将始终复制字符串,但切片只会借用: `&s[0..2]`. 

`Vec<T>`和`&[T]`之间有一个等价的关系. 

### 共享引用

 Rust 有 _聪明的指针_ 像C ++  - 例如,相当于`std::unique_ptr`是`Box`. 没有必要`删除`,因为任何内存或其他资源将在盒子超出范围时被回收 ( Rust 非常包含RAII) . 

``` Rust 
let mut answer = Box::new("hello".to_string());
*answer = "world".to_string();
answer.push('!');
println!("{} {}", answer, answer.len());
```

人们发现`to_string`起初有点刺激,但事实确实如此 _明确的_. 

注意显式的取值`*`,但智能指针上的方法不需要任何特殊符号 (我们不会这么说`(*answer).push('!')`) 

显然,只有在原始内容明确定义的所有者的情况下,借用才有效. 在许多设计中,这是不可能的. 

在C ++中,这是`std::shared_ptr的`用处;复制仅涉及修改公用数据的引用计数. 但这不是没有成本的: 

-   即使数据是只读的,不断修改引用计数也会导致缓存失效
-   `std::shared_ptr`被设计成线程安全的并且也承载锁定开销

在 Rust ,`std::rc::Rc`也像使用引用计数的共享智能指针一样工作. 但是,它仅适用于不可变引用! 如果你想要一个线程安全的变体,请使用`std::sync::Arc` ('Atomic Rc') . 所以 Rust 在提供两种变体方面有些尴尬,但你可以避免非线程操作的锁定开销. 

这些必须是不可变的引用,因为这是 Rust 内存模型的基础. 但是,有一张退出卡: `std::cell::RefCell`. 如果您将共享引用定义为`Rc<RefCell<T>>`那么你可以可变地借用它的`borrow_mut`方法. 这适用 Rust 的借用规则 _动态_- 例如任何尝试使用`borrow_mut`,然而借用已经发生会引起恐慌. 

这仍然是 _安全_. 恐慌会任何内存都被不当地触动 _之前_ 发生! 像例外情况一样,他们展开调用堆栈. 所以对于这样一个结构化的过程来说这是一个不幸的词 - 这是一个有序的撤退 而不是 恐慌的撤退. 

完整的`Rc<RefCell<T>>`类型笨拙,但应用程序代码并不令人不快.  Rust  (再次) 倾向于明确表示. 

如果你想线程安全地访问共享状态,那么`Arc<T>`是唯一的 _安全_ 要走的路. 如果你需要可变权限,那么`Arc<Mutex<T>>`相当于`Rc<RefCell<T>>`. `Mutex`与通常定义的方式有点不同: 它是一个值的容器.  在 值 上你得到一个 _锁{lock}_,然后可以修改它. 

``` Rust 
let answer = Arc::new(Mutex::new(10));

// in another thread
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}
```

为什么`unwrap`? 如果前面的持有线程恐慌,那么这个`锁`失败.  (这是文档中的一个地方,`unwrap`被认为是合理的事情,因为事情显然已经严重错误. 恐慌总是可以在线索中发现. ) 

重要的是 (像往常一样使用 Mutex 锁) 这个排他锁尽可能少地保留下来. 所以它们在一个有限的范围内发生是很常见的 - 然后当可变引用超出范围时锁定结束. 

与C ++中显然更简单的情况 ("use shared_ptr dude") ,这看起来很尴尬,但是现在任何共享状态的 _修改_ 都变得明显，
和“互斥锁{Mutex}”锁定模式强制线程安全。

像所有内容一样，使用共享引用[警告](https://news.ycombinator.com/item?id=11698784)

### 迭代器

C ++中的迭代器非常非正式地定义;

他们涉及智能指针,通常从头开始`c.begin()`并以`c.end()`结束. 迭代器上的操作然后作为独立的模板函数来实现,如`std::find_if`. 

 Rust 迭代器由`Iterator` trait 定义;`next`返回一个`Option`和什么时候`Option`是`None`我们结束了. 

最常见的操作是现在的方法. 这是等价的`find_if`. 它返回一个`Option` (没有发现的情况是`None`) 和这里`if let`语句可以方便地提取 非-`None` 案件: 

``` Rust 
let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res is 2
}
```

### 不安全和链接列表

Rust  stdlib 的某些部分实现是使用 `unsafe`的. 并不是什么秘密. 这并不妨碍借 用检查员 的保守方法. 请记住,"unsafe"具有特殊意义 -   Rust 在编译时无法完全验证的操作. 从 Rust 的角度来看,C ++始终处于不安全的模式!所以如果一个大的应用程序需要几十行不安全的代码,那很好,因为这几行代码可以被人仔细检查. 人类不善于检查 100Kloc +的代码. 

我提到这一点,因为似乎有一种模式: 一个有经验的 C ++人 试图实现 链表或树结构,并且感到沮丧. 那么,一个双链表 _是_ 可能在安全的 Rust ,与`Rc`引用前进,和`Weak`引用回去. 但是标准库在使用指针方面仍需要获得了更多的性能. 
