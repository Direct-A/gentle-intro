
## 痛点

可以说Rust是一门比大多数"主流"语言更难学的语言. 有特殊的人不觉得这么难,但要注意'特殊'的严格意义 - 他们是_例外_. 许多人开始挣扎,然后成功. 最初的困难不能预测后来的能力!

我们都来自某个地方,在编程语言的情况下,这意味着以前暴露于主流语言,如Python之类的"动态"语言或C ++之类的"静态"语言之一. 无论哪种方式,Rust都有很大的不同,需要精神改造. 有经验的聪明人加入进来,对他们的聪明不立即获得回报感到失望;自我价值较低的人认为自己不够"聪明". 

对于那些具有动态语言经验的人 (我将包括Java) ,所有内容都是引用,并且所有引用默认都是可变的. 和垃圾收集_不_使编写内存安全的程序更容易. 以内存使用和可预测性为代价,JVM进展非常迅速. 通常这种成本被认为是值得的 - 旧的新想法认为程序员的生产力比计算机的性能更重要. 

但是世界上大多数电脑 - 处理汽车节气门控制等真正重要的事情 - 并不具备便宜笔记本电脑所拥有的大量资源,而且他们需要响应_即时的_. 同样,基础软件基础架构需要正确,稳健和快速 (旧的工程三位一体) . 这大部分都是在C和C ++中完成的,这本质上是不安全的_总成本_这个不安全的东西是在这里看的东西. 也许你更快地把节目敲在一起,但是_然后_真正的发展开始. 

系统语言无法承担垃圾回收,因为它们是所有东西都依赖的基础. 他们让你可以自由地浪费资源,只要你认为合适. 

如果没有垃圾回收,则内存必须以其他方式进行管理. 手动内存管理 - 我抓住内存,使用它,并明确地将其退回 - 很难找到正确的内容. 您可以在几周内学会足够的C语言以提高工作效率和危险性 - 但要成为一名安全的C语言程序员需要花费数年时间,检查每种可能的错误情况. 

Rust像现代C ++一样管理内存 - 随着对象被破坏,内存被回收. 你可以在堆上分配内存`框`,但只要该函数在函数结束时'超出范围',内存就会被回收. 所以有这样的事情`新`但没有像`删除`. 你创建一个`文件`最后,文件句柄 (一个宝贵的资源) 被关闭. 在Rust中,这被称为_落下_. 

你需要共享资源 - 复制一切都是非常低效的 - 这就是事情变得有趣的地方. C ++也有引用,尽管Rust引用更像C指针 - 你需要说`* R`要提及价值,你需要说`&`传递一个值作为参考. 

锈的_借用检查器_确保在原始值被销毁后参考不可能存在. 

## 类型推断

"静态"和"动态"之间的区别不是一切. 与大多数事情一样,还有更多维度在发挥. C是静态类型的 (每个变量在编译时都有一个类型) ,但是类型很弱 (例如,`无效*`可以指向_什么_) ;Python是动态类型的 (类型在值中,而不是变量) ,但是是强类型的. Java是静态/非常强大的 (反射就像方便/危险的逃逸阀) ,Rust是静态/强大的,没有运行时反射. 

Java因需要所有的类型而出名_键入_在麻木的细节中,Rust喜欢_推断_类型. 这通常是一个好主意,但这确实意味着你有时需要计算出实际类型. 你会看见`让n = 100`并想知道 - 这是什么样的整数?默认情况下,它会是`i32`- 一个四字节有符号整数. 现在大家都同意C的未指定整数类型 (比如`int`和`长`) 是一个坏主意;最好是明确的. 你可以随时拼出类型,如`让n: u32 = 100`或者让文字强制类型,如`让n = 100u32`. 但是类型推断比这更进一步!如果你声明`让n = 100`然后全部`rustc`知道这一点`ñ`一定是_一些_整数类型. 如果你然后通过`ñ`到函数期望a`u64`那么这一定是这种类型的`ñ`!

之后,你尝试通过`ñ`以期望的功能`u32`. `rustc`不会让你这样做,因为`ñ`已被束缚到`u64`和它_将不会_采取简单的方法,并为您转换该整数. 这是强有力的打字行动 - 没有任何一点转换和促销活动让你的生活更流畅,直到整数溢出突然咬住你的屁股. 你必须明确地通过`ñ`如`像u32一样`- 一个Rust类型. 幸好,`rustc`善于以"可行"的方式打破坏消息 - 也就是说,您可以按照编译器的意见来解决问题. 

所以,Rust代码可以非常明确的类型: 

```rust
let mut v = Vec::new();
// v is deduced to have type Vec<i32>
v.push(10);
v.push(20);
v.push("hello") <--- just can't do this, man!
```

不能将字符串放入整数向量是一个功能,而不是一个错误. 动态打字的灵活性也是一个诅咒. 

 (如果你_做_需要将整数和字符串放入同一个向量,然后Rust`枚举`类型是安全地使用它的方法. ) 

有时你需要至少给一个类型_暗示_. `搜集`是一个梦幻般的迭代器方法,但它需要一个提示. 说我有一个迭代器返回`烧焦`. 然后`搜集`可以摆动两种方式: 

```rust
// a vector of char ['h','e','l','l','o']
let v: Vec<_> = "hello".chars().collect();
// a string "doy"
let m: String = "dolly".chars().filter(|&c| c != 'l').collect();
```

当对某个变量的类型感到不确定时,总会有这种技巧,这种力量`rustc`在错误消息中显示实际类型名称: 

```rust
let x: () = var;
```

`rustc`可能会选择特定类型. 这里我们想把不同的引用放入一个向量中`和调试`但需要明确声明类型. 

```rust
use std::fmt::Debug;

let answer = 42;
let message = "hello";
let float = 2.7212;

let display: Vec<&Debug> = vec![&message, &answer, &float];

for d in display {
    println!("got {:?}", d);
}
```

## 可变参考

规则是: 一次只有一个可变引用. 原因在于追踪可变性很难发生_到处都是_. 在小笨蛋程序中不明显,但在大型代码库中可能会变得糟糕. 

进一步的限制是,当有可变引用出现时,你不能拥有不可变引用. 否则,任何有这些引用的人都不能保证他们不会改变. C ++也有不可变的引用 (例如`常量字符串&`) 但是_不_给你这个保证,有人不能保留一个`串&`参考并在背后修改它. 

如果您习惯于每个参考都是可变的语言,这是一个挑战!不安全的"放松"语言取决于人们了解他们自己的计划并高高兴兴地决定不做坏事. 但是大型项目是由不止一个人编写的,并且超出了单个人详细理解的能力. 

该_刺激性_事情是,借用检查器并不像它那样聪明. 

```rust
let mut m = HashMap::new();
m.insert("one", 1);
m.insert("two", 2);

if let Some(r) = m.get_mut("one") { // <-- mutable borrow of m
    *r = 10;
} else {
    m.insert("one", 1); // can't borrow mutably again!
}
```

显然这不是_真_违反规则,因为如果我们得到了`没有`我们实际上并没有从地图上借用任何东西. 

有各种丑陋的解决方法: 

```rust
let mut found = false;
if let Some(r) = m.get_mut("one") {
    *r = 10;
    found = true;
}
if ! found {
    m.insert("one", 1);
}
```

这很糟糕,但它起作用,因为令人烦恼的借款保留在第一个if语句中. 

这里更好的方法是使用`HashMap中`的[入门API](https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html). 

```rust
use std::collections::hash_map::Entry;

match m.entry("one") {
    Entry::Occupied(e) => {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) => {
        e.insert(1);
    }
};
```

借阅检查器在获得更少的挫败感时_非词汇生活时间_今年某个时候到达. 

借用检查器_不_了解一些重要的案例,但是. 如果你有一个结构,字段可以独立借用. 所以作文是你的朋友;一个大结构体应该包含更小的结构体,它们有自己的方法. 定义大结构体上的所有可变方法将导致无法修改内容的情况,即使这些方法可能只涉及一个字段. 

对于可变数据,有一些独立处理数据部分的特殊方法. 例如,如果你有一个可变片,那么`split_at_mut`将它分成两个可变片. 这是完全安全的,因为Rust知道切片不重叠. 

## 参考文献和生命时间

锈不能允许一个参考超过价值的情况. 否则,我们会有一个"悬挂参考",它指的是一个死亡值 - 一个段错误是不可避免的. 

`rustc`往往可以对功能的生命周期做出合理的假设: 

```rust
fn pair(s: &str, ch: char) -> (&str, &str) {
    if let Some(idx) = s.find(ch) {
        (&s[0..idx], &s[idx+1..])
    } else {
        (s, "")
    }
}
fn main() {
    let p = pair("hello:dolly", ':');
    println!("{:?}", p);
}
// ("hello", "dolly")
```

这是非常安全的,因为我们处理了未找到分隔符的情况. `rustc`在这里假定元组中的两个字符串都是从作为参数传递给函数的字符串中借用的. 

明确地说,函数定义如下所示: 

```rust
fn pair<'a>(s: &'a str, ch: char) -> (&'a str, &'a str) {...}
```

符号表示输出字符串存在_至少与之一样长_作为输入字符串. 这并不是说生命是一样的,我们可以在任何时候放弃它们,只是因为它们无法活力`小号`. 

所以,`rustc`使常见案例更漂亮_终身豁免_. 

现在,如果收到该功能_二_字符串,那么您需要明确地进行生命周期注释来告诉Rust哪个输出字符串是从哪个输入字符串中借用的. 

当一个结构借用一个引用时,你总是需要一个明确的生命周期: 

```rust
struct Container<'a> {
    s: &'a str
}
```

这再次坚持结构不能超过参考. 对于结构和函数,生命周期都需要在中声明`<>`像一个类型参数. 

关闭是非常方便和强大的功能 -  Rust迭代器的很多强大功能都来自它们. 但是如果你存储它们,你必须指定一个生命周期. 这是因为基本上闭包是一个可以调用的生成结构,并且默认情况下是借用它的环境. 在这里`线性`闭包有不可改变的引用`米`和`c`. 

```rust
let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c;
let sc = |x| m*x.cos()
...
```

都`线性`和`sc`实行`Fn (x: f64) →f64`但他们是_不_同样的动物 - 他们有不同的类型和大小!所以要存储它们,你必须做出一个`Box <Fn (x: f64)  - > f64 +'a>`. 

非常烦人,如果你习惯了JavaScript或Lua的流畅关闭,但C ++与Rust类似,并且需要`的std ::功能`存储不同的关闭,对虚拟呼叫采取一点点惩罚. 

## 字符串

在开始时,通常会对Rust字符串感到恼火. 有不同的方式来创建它们,并且它们都感觉冗长: 

```rust
let s1 = "hello".to_string();
let s2 = String::from("dolly");
```

不是"你好"_已经_一个字符串?好吧,在某种程度上. `串`是一个_拥有的_字符串,分配在堆上;字符串文字"hello"是类型的`&STR` ("字符串片") ,并可能被烘焙到可执行文件 ("静态") 或借用`串`. 系统语言需要这种区别 - 考虑一个微型微控制器,它有一点RAM和更多的ROM. 文字字符串将被存储在ROM中 ("只读") ,这既便宜又消耗更少的功率. 

但是 (你可能会说) 在C ++中它非常简单: 

```C
std::string s = "hello";
```

其中较短的是,但隐藏了字符串对象的隐式创建. 因此,Rust喜欢明确分配内存`to_string`. 另一方面,借用一个C ++字符串需要`c_str`,而C字符串很蠢. 

幸运的是,Rust的情况更好 -_一旦_你接受这两个`串`和`&STR`是必要的. 的方法`串`主要是为了改变字符串,就像`推`添加一个字符 (在引擎盖下它非常像`VEC <U8>`) . 但是所有的方法`&STR`也可用. 同样的`Deref`机制,a`串`可以通过`&STR`到一个功能 - 这就是为什么你很少看到`&串`在函数定义中. 

有很多方法可以转换`&STR`至`串`,对应于各种特征. Rust需要这些特征来一般地处理类型. 作为一个经验法则,任何实现`显示`也知道`to_string`, 喜欢`42.to_string () `. 

一些运营商可能不会按照直觉行事: 

```rust
    let s1 = "hello".to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == "hello"); // fine
    assert!(s1 == &s2); // WTF?
```

记得,`串`和`&串`是不同的类型,和`==`没有为该组合定义. 这可能会让一个习惯于引用的C ++人与数值几乎可以互换. 此外,`&S2`不_神奇_成为一个`&STR`, 那是一个_deref强制_这只在分配给a时才会发生`&STR`变量或参数.  (明确的`s2.as_str () `会工作. ) 

但是,这更真正值得一个WTF: 

```rust
let s3 = s1 + s2;  // <--- no can do
```

你不能连接两个`串`值,但可以连接一个`串`与`&STR`. 此外,您不能连接一个`&STR`与`串`. 所以大多数人不会使用`+`并使用`格式!`宏,这很方便,但效率不高. 

有些字符串操作可用,但工作方式不同. 例如,语言通常有一个`分裂`将字符串分解为字符串数组的方法. Rust字符串的这个方法返回一个_迭代器_,你可以_然后_收集成矢量. 

```rust
let parts: Vec<_> = s.split(',').collect();
```

如果你急于获取矢量,这有点笨拙. 但是你可以对零件进行操作_无_分配一个矢量!例如,分割中最大的字符串的长度?

```rust
let max = s.split(',').map(|s| s.len()).max().unwrap();
```

 (该`摅`是因为空的迭代器没有最大值,我们必须覆盖这种情况. ) 

该`搜集`方法返回一个`VEC <&STR>`,其中的部分是从原始字符串中借用的 - 我们只需要为引用分配空间. 在C ++中没有像这样的方法,但直到最近才需要单独分配每个子字符串.  (C ++ 17有`的std :: string_view`其行为像一个Rust字符串切片. ) 

## 关于分号的说明

分号是_不_可选的,但通常在与C相同的地方被排除,例如,后`{}`块. 之后他们也不需要`枚举`要么`结构` (这是一个C特性. ) 但是,如果该块必须有一个_值_,那么分号将被丢弃: 

```rust
    let msg = if ok {"ok"} else {"error"};
```

请注意,在此之后必须有一个分号`让`声明!

如果在这些字符串之后有分号,那么返回的值就是` () ` (喜欢`没有`要么`空虚`) . 定义函数时常见错误: 

```rust
fn sqr(x: f64) -> f64 {
    x * x;
}
```

`rustc`在这种情况下会给你一个明确的错误. 

## 特定于C ++的问题

### 锈值语义是不同的

在C ++中,可以定义类似于原语的类型并复制它们自己. 另外,可以定义移动构造函数来指定如何将值移出临时上下文. 

在Rust里,原始人的行为和预期一样,但是`复制`trait只能在集合类型 (结构,元组或枚举) 本身只包含可复制类型的情况下定义. 任意类型可能有`克隆`,但你必须打电话给`克隆`方法的值. Rust要求任何分配都是明确的,不要隐藏在复制构造函数或赋值运算符中. 

所以,复制和移动总是被定义为只是移动位而不能被覆盖. 

如果`s1`是非的`复制`值类型,然后`s2 = s1;`导致移动发生,而这_消耗_ `s1`!所以,当你真的想要一个副本,使用`克隆`. 

借用通常比复制要好,但是你必须遵循借用规则. 幸运的是,借款_是_一个可覆盖的行为. 例如,`串`可以借用`&STR`,并共享所有不可变的方法`&STR`. _字符串切片_与类似的C ++"借用"操作相比,这是非常强大的功能,它将提取一个`const char *`运用`c_str`. `&STR`由一个指向一些拥有的字节 (或字符串文字) 和一个指针组成_尺寸_. 这导致了一些非常有效的内存模式. 你可以有一个`VEC <&STR>`所有的字符串都是从一些底层字符串中借用的 - 只需要分配矢量空间: 

例如,按空格拆分: 

```rust
fn split_whitespace(s: &str) -> Vec<&str> {
    s.split_whitespace().collect()
}
```

同样,一个C ++`s.substr (0,2) `调用将始终复制字符串,但切片只会借用: `&S [0..2]`. 

之间有一个等价的关系`VEC <T>`和`&[T]`. 

### 共享引用

Rust有_聪明的指针_像C ++  - 例如,相当于`的std ::的unique_ptr`是`框`. 没有必要`删除`,因为任何内存或其他资源将在盒子超出范围时被回收 (Rust非常包含RAII) . 

```rust
let mut answer = Box::new("hello".to_string());
*answer = "world".to_string();
answer.push('!');
println!("{} {}", answer, answer.len());
```

人们发现`to_string`起初有点刺激,但事实确实如此_明确的_. 

注意显式的dererefence`*`,但智能指针上的方法不需要任何特殊符号 (我们不这么说` (*答案) .push ( '!') `) 

显然,只有在原始内容明确定义的所有者的情况下,借款才有效. 在许多设计中,这是不可能的. 

在C ++中,这是在哪里`的std :: shared_ptr的`用来;复制仅涉及修改公用数据的引用计数. 但这不是没有成本的: 

-   即使数据是只读的,不断修改引用计数也会导致缓存失效
-   `的std :: shared_ptr的`被设计成线程安全的并且也承载锁定开销

在铁锈,`的std :: RC: RC`也像使用引用计数的共享智能指针一样工作. 但是,它仅适用于不可变引用!如果你想要一个线程安全的变体,请使用`的std ::同步::弧` ('Atomic Rc') . 所以Rust在提供两种变体方面有些尴尬,但你可以避免非线程操作的锁定开销. 

这些必须是不可变的参考,因为这是Rust内存模型的基础. 但是,有一张退出卡: `的std ::电池:: RefCell`. 如果您将共享引用定义为`RC <RefCell <T >>`那么你可以可变地借用它的`borrow_mut`方法. 这适用Rust的借款规则_动态_- 例如任何尝试打电话`borrow_mut`当借款已经发生会引起恐慌. 

这仍然是_安全_. 恐慌会发生_之前_任何内存都被不当地触动!像例外情况一样,他们展开调用堆栈. 所以对于这样一个结构化的过程来说这是一个不幸的词 - 这是一个有序的撤退而不是恐慌的撤退. 

完整的`RC <RefCell <T >>`类型笨拙,但应用程序代码并不令人不快. Rust (再次) 倾向于明确表示. 

如果你想线程安全地访问共享状态,那么`弧<T>`是唯一的_安全_要走的路. 如果你需要可变权限,那么`弧<互斥<T >>`相当于`RC <RefCell <T >>`. `互斥`与通常定义的方式有点不同: 它是一个值的容器. 你得到一个_锁_在价值上,然后可以修改它. 

```rust
let answer = Arc::new(Mutex::new(10));

// in another thread
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}
```

为什么`摅`?如果前面的持有线程恐慌,那么这个`锁`失败.  (这是文档中的一个地方`摅`被认为是合理的事情,因为事情显然已经严重错误. 恐慌总是可以在线索中发现. ) 

重要的是 (像往常一样使用互斥锁) 这个排他锁尽可能少地保留下来. 所以它们在一个有限的范围内发生是很常见的 - 然后当可变参考超出范围时锁定结束. 

与C ++中显然更简单的情况 ("use shared_ptr dude") ,这看起来很尴尬,但现在任何修改共享状态变得明显,而且_互斥`锁定模式强制螺纹安全. `像所有内容一样,使用共享引用

警告[. ](https://news.ycombinator.com/item?id=11698784)迭代器

### C ++中的迭代器非常非正式地定义;

他们涉及智能指针,通常从头开始c.begin () `并以...结束`c.end () `. `迭代器上的操作然后作为独立的模板函数来实现,如`的std :: find_if`. 

Rust迭代器由.de定义`迭代器`特征;`下一个`返回一个`选项`和什么时候`选项`是`没有`我们结束了. 

最常见的操作是现在的方法. 这是等价的`find_if`. 它返回一个`选项` (没有发现的情况是`没有`) 和这里`如果让`语句可以方便地提取non-`没有`案件: 

```rust
let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res is 2
}
```

### 不安全和链接列表

Rust stdlib的某些部分是使用实现的并不是什么秘密`不安全`. 这并不妨碍借款检查员的保守方法. 请记住,"不安全"具有特殊意义 -  Rust在编译时无法完全验证的操作. 从Rust的角度来看,C ++始终处于不安全的模式!所以如果一个大的应用程序需要几十行不安全的代码,那很好,因为这几行代码可以被人仔细检查. 人类不善于检查100Kloc +的代码. 

我提到这一点,因为似乎有一种模式: 一个有经验的C ++人试图实现链表或树结构,并且感到沮丧. 那么,一个双链表_是_可能在安全的铁锈,与`Rc`参考前进,和`弱`引用回去. 但是标准库在使用...指针方面获得了更多的性能. 
